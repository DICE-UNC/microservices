/*
 * libmsiGetDataObjAIP.cpp
 */



// =-=-=-=-=-=-=-
#include "eraUtil.h"
#include "rsGenQuery.hpp"
#include "rsObjStat.hpp"

#include "irods_error.hpp"
#include "irods_ms_plugin.hpp"

extern "C"{
    /**
     * \fn msiGetDataObjAIP(msParam_t *inpParam, msParam_t *outParam, ruleExecInfo_t *rei)
     *
     * \brief This microservice gets the Archival Information Package of a data object.
     *
     * \module ERA
     *
     * \since pre-2.1
     *
     * \author  Antoine de Torcy
     * \date   2007-09-26
     *
     * \note The results are returned as an XML file.
     *
     * \usage See clients/icommands/test/rules3.0/
     *
     * \param[in] inpParam - A DataObjInp_MS_T or a STR_MS_T with the iRODS path of the target object.
     * \param[out] outParam - A BUF_LEN_MS_T containing the results.
     * \param[in,out] rei - The RuleExecInfo structure that is automatically
     *    handled by the rule engine. The user does not include rei as a
     *    parameter in the rule invocation.
     *
     * \DolVarDependence None
     * \DolVarModified None
     * \iCatAttrDependence None
     * \iCatAttrModified None
     * \sideeffect None
     *
     * \return integer
     * \retval 0 on success
     * \pre None
     * \post None
     * \sa None
    **/
    int
    msiGetDataObjAIP(msParam_t *inpParam, msParam_t *outParam, ruleExecInfo_t *rei)
    {
       rsComm_t *rsComm; 
       dataObjInp_t dataObjInp, *myDataObjInp;
       bytesBuf_t *mybuf;

       genQueryInp_t genQueryInp;
       genQueryOut_t *genQueryOut;
       int i1a[30];
       int i1b[30];
       int i2a[30];
       char *condVal[30];
       char v1[MAX_NAME_LEN];
       char v2[MAX_NAME_LEN];
       char fullName[MAX_NAME_LEN];
       char myDirName[MAX_NAME_LEN];
       char myFileName[MAX_NAME_LEN];
       int printCount=0, i;
       char *tags[30];

       char tmpStr[MAX_NAME_LEN];
       rodsObjStat_t *rodsObjStatOut;

       RE_TEST_MACRO ("    Calling GetDataObjAIP")

       if (rei == NULL || rei->rsComm == NULL) {
        rodsLog (LOG_ERROR,
          "msiGetDataObjAIP: input rei or rsComm is NULL");
        return (SYS_INTERNAL_NULL_INPUT_ERR);
       }

       rsComm = rei->rsComm;

       /* parse inpParam1 */
       rei->status = parseMspForDataObjInp (inpParam, &dataObjInp, &myDataObjInp, 0);

       if (rei->status < 0) {
        rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
              "msiGetDataObjAIP: input inpParam1 error. status = %d", rei->status);
        return (rei->status);
       }

       /* Extract cwd name and object name */
       strncpy(fullName, myDataObjInp->objPath, MAX_NAME_LEN);
       rei->status = splitPathByKey(fullName, myDirName, MAX_NAME_LEN, myFileName, MAX_NAME_LEN, '/');


       /* buffer init */
       mybuf = (bytesBuf_t *)malloc(sizeof(bytesBuf_t));
       memset (mybuf, 0, sizeof (bytesBuf_t));


       /* Prepare XML output */
       appendStrToBBuf(mybuf, "<?xml version='1.0' encoding='utf-8'?>\n");
       appendStrToBBuf(mybuf, "<!-- Generated by SDSC iRODS (http://www.irods.org) -->\n");
       appendStrToBBuf(mybuf, "<AIP>\n");


       /* First we're going to query the ICAT for system metadata */
       tags[0]=strdup("");
       tags[1]=strdup("D_DATA_ID");
       tags[2]=strdup("D_COLL_ID");
       tags[3]=strdup("DATA_NAME");
       tags[4]=strdup("DATA_REPL_NUM");
       tags[5]=strdup("DATA_VERSION");
       tags[6]=strdup("DATA_TYPE_NAME");
       tags[7]=strdup("DATA_SIZE");
       tags[8]=strdup("D_RESC_GROUP_NAME");
       tags[9]=strdup("D_RESC_NAME");
       tags[10]=strdup("D_DATA_PATH");
       tags[11]=strdup("D_OWNER_NAME");
       tags[12]=strdup("D_OWNER_ZONE");
       tags[13]=strdup("D_REPL_STATUS");
       tags[14]=strdup("D_DATA_STATUS");
       tags[15]=strdup("D_DATA_CHECKSUM");
       tags[16]=strdup("D_EXPIRY");
       tags[17]=strdup("D_MAP_ID");
       tags[18]=strdup("D_COMMENTS");
       tags[19]=strdup("D_CREATE_TIME");
       tags[20]=strdup("D_MODIFY_TIME");


       memset (&genQueryInp, 0, sizeof (genQueryInp_t));

       i1a[0]=COL_D_DATA_ID;
       i1a[1]=COL_D_COLL_ID;
       i1a[2]=COL_DATA_NAME;
       i1a[3]=COL_DATA_REPL_NUM;
       i1a[4]=COL_DATA_VERSION;
       i1a[5]=COL_DATA_TYPE_NAME;
       i1a[6]=COL_DATA_SIZE;
       i1a[7]=COL_D_RESC_HIER;
       i1a[8]=COL_D_RESC_NAME;
       i1a[9]=COL_D_DATA_PATH;
       i1a[10]=COL_D_OWNER_NAME;
       i1a[11]=COL_D_OWNER_ZONE;
       i1a[12]=COL_D_REPL_STATUS;
       i1a[13]=COL_D_DATA_STATUS;
       i1a[14]=COL_D_DATA_CHECKSUM;
       i1a[15]=COL_D_EXPIRY;
       i1a[16]=COL_D_MAP_ID;
       i1a[17]=COL_D_COMMENTS;
       i1a[18]=COL_D_CREATE_TIME;
       i1a[19]=COL_D_MODIFY_TIME;

       for (i=0; i<20; i++) {
       i1b[i]=0; /* currently unused */
       }

       genQueryInp.selectInp.inx = i1a;
       genQueryInp.selectInp.value = i1b;
       genQueryInp.selectInp.len = 20;


       i2a[0]=COL_COLL_NAME;
       sprintf(v1,"='%s'",myDirName);
       condVal[0]=v1;

       i2a[1]=COL_DATA_NAME;
       sprintf(v2,"='%s'",myFileName);
       condVal[1]=v2;

       genQueryInp.sqlCondInp.inx = i2a;
       genQueryInp.sqlCondInp.value = condVal;
       genQueryInp.sqlCondInp.len=2;

       genQueryInp.maxRows=30;
       genQueryInp.continueInx=0;
       genQueryInp.condInput.len=0;


       /* First rsGenQuery() call for system metadata */
       rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);




       /* Parse and print out results */
       if (rei->status == CAT_NO_ROWS_FOUND) {
          i1a[0]=COL_D_DATA_PATH;
          genQueryInp.selectInp.len = 1;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          if (rei->status==0) {
              freeGenQueryOut (&genQueryOut);
          }
          if (rei->status == CAT_NO_ROWS_FOUND) {

        rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
              "msiGetDataObjAIP: DataObject %s not found. status = %d", fullName, rei->status);
        return (rei->status);
          }
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }
       else {
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }

       while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
          genQueryInp.continueInx=genQueryOut->continueInx;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
       }


      /* Now we're going to query the ICAT for user defined metadata. One hit = one AVU triplet */
       tags[0]=strdup("AVU");
       tags[1]=strdup("attribute");
       tags[2]=strdup("value");
       tags[3]=strdup("units");

       memset (&genQueryInp, 0, sizeof (genQueryInp_t));

       i1a[0]=COL_META_DATA_ATTR_NAME;
       i1b[0]=0; /* currently unused */
       i1a[1]=COL_META_DATA_ATTR_VALUE;
       i1b[1]=0; /* currently unused */
       i1a[2]=COL_META_DATA_ATTR_UNITS;
       i1b[2]=0; /* currently unused */
       genQueryInp.selectInp.inx = i1a;
       genQueryInp.selectInp.value = i1b;
       genQueryInp.selectInp.len = 3;

       /* Extract cwd name and object name */
       strncpy(fullName, myDataObjInp->objPath, MAX_NAME_LEN);
       rei->status = splitPathByKey(fullName, myDirName, MAX_NAME_LEN, myFileName, MAX_NAME_LEN, '/');

       i2a[0]=COL_COLL_NAME;
       sprintf(v1,"='%s'",myDirName);
       condVal[0]=v1;

       i2a[1]=COL_DATA_NAME;
       sprintf(v2,"='%s'",myFileName);
       condVal[1]=v2;


       genQueryInp.sqlCondInp.inx = i2a;
       genQueryInp.sqlCondInp.value = condVal;
       genQueryInp.sqlCondInp.len=2;

       genQueryInp.maxRows=10;
       genQueryInp.continueInx=0;
       genQueryInp.condInput.len=0;

       /* rsGenQuery() call for user defined metadata */
       rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);

       /* Parse and print out results */
       if (rei->status == CAT_NO_ROWS_FOUND) {
          i1a[0]=COL_D_DATA_PATH;
          genQueryInp.selectInp.len = 1;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          if (rei->status==0) {
              freeGenQueryOut (&genQueryOut);
          }
          if (rei->status == CAT_NO_ROWS_FOUND) {

        rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
              "msiGetDataObjAVUs: DataObject %s not found. status = %d", fullName, rei->status);
        return (rei->status);
          }
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }
       else {
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }

       while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
          genQueryInp.continueInx=genQueryOut->continueInx;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
       }

        /* Same thing again, but this time for user access */
        tags[0]=strdup("ACL");
        tags[1]=strdup("COL_DATA_ACCESS_TYPE");
        tags[2]=strdup("COL_DATA_ACCESS_NAME");
        tags[3]=strdup("COL_DATA_TOKEN_NAMESPACE");
        tags[4]=strdup("COL_DATA_ACCESS_USER_IDM");
        tags[5]=strdup("COL_DATA_ACCESS_DATA_ID");

        memset (&genQueryInp, 0, sizeof (genQueryInp_t));

        rei->status = rsObjStat(rsComm, &dataObjInp, &rodsObjStatOut);

        addInxIval (&genQueryInp.selectInp, COL_USER_NAME, 1);
        addInxIval (&genQueryInp.selectInp, COL_DATA_ACCESS_NAME, 1);

        snprintf (tmpStr, MAX_NAME_LEN, " = '%s'", rodsObjStatOut->dataId);

        addInxVal (&genQueryInp.sqlCondInp, COL_DATA_ACCESS_DATA_ID, tmpStr);

        snprintf (tmpStr, MAX_NAME_LEN, "='%s'", "access_type");

        /* Currently necessary since other namespaces exist in the token table */
        addInxVal (&genQueryInp.sqlCondInp, COL_DATA_TOKEN_NAMESPACE, tmpStr);

        genQueryInp.maxRows = MAX_SQL_ROWS;

        rei->status =  rsGenQuery (rsComm, &genQueryInp, &genQueryOut);

       /* Parse and print out results */
       if (rei->status == CAT_NO_ROWS_FOUND) {
          i1a[0]=COL_D_DATA_PATH;
          genQueryInp.selectInp.len = 1;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          if (rei->status==0) {
              freeGenQueryOut (&genQueryOut);
          }
          if (rei->status == CAT_NO_ROWS_FOUND) {

        rodsLogAndErrorMsg (LOG_ERROR, &rsComm->rError, rei->status,
              "msiGetDataObjAIP: DataObject %s not found. status = %d", fullName, rei->status);
        return (rei->status);
          }
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }
       else {
          printCount+=genQueryOutToXML(genQueryOut, mybuf, tags);
       }

       while (rei->status==0 && genQueryOut && genQueryOut->continueInx > 0) {
          genQueryInp.continueInx=genQueryOut->continueInx;
          rei->status = rsGenQuery(rsComm, &genQueryInp, &genQueryOut);
          printCount+= genQueryOutToXML(genQueryOut, mybuf, tags);
       }


      /* Closing tag */
      appendStrToBBuf(mybuf, "</AIP>\n");


      fillBufLenInMsParam (outParam, strlen((char*)mybuf->buf), mybuf);

      return (rei->status);

    }

irods::ms_table_entry * plugin_factory() {
        irods::ms_table_entry* msvc = new irods::ms_table_entry(2);
        msvc->add_operation<
            msParam_t*,
            msParam_t*,
            ruleExecInfo_t*>("msiGetDataObjAIP",
                             std::function<int(
                                 msParam_t*,
                                 msParam_t*,
                                 ruleExecInfo_t*)>(msiGetDataObjAIP));


        return msvc;
    }
}
